---
title: "The raising floor of building apps in 2026"
date_published: "2026-01-09"
date_updated: "2026-01-09"
excerpt: "The floor for building apps keeps rising. In 2026, you can build meaningful software with plain English. But what's the difference between an experienced engineer and a newcomer using Claude Code?"
tags: ["Tech", "Daily Reflection"]
fav: false
creation_duration_minutes: 23
backlinks:
---

I’m talking to a friend who was a principal PM turned solo entrepreneur and this topic came up.

He asked in passing, and I quote him:

> “how do you learn today? Sill need fundamentals. But also experience with a job to understand like higher architectural things.”

> “I don’t want to really master getters and setters.”

> “But at the same time want to understand fully what is going on in the code end to end”

> “I think learning to code now should be vastly different but I am not sure what it is”

This is a tricky question, because if you asked me this in 2025, I would probably have a different answer.

But one thing I'm sure about is this: you still need software engineering fundamentals, and I predict you'll need this until AI starts designing apps in an "alien language" (see [AI 2027](https://ai-2027.com/))

What I’ve noticed is that the floor is being raised.

This phenomenon of needing to know less in order to achieve the same outcomes is completely natural due to the increasing stability of abstraction layers that we work with as application developers.

When I [started as a junior software engineer](/2021-07-04-reflecting-on-my-career-in-tech-5-years-in/) in 2015, the floor was around JavaScript. I didn’t need to know about garbage collection and memory pointers to do my job, like my predecessors had to from a decade ago.

Dig deeper underground and you’ll get to assembly language and compilers. You can keep going deeper until you get to binary and transistors.

So the floor continues to be raised. The only one noteworthy difference is the **speed** at which the floor is being raised.

It’s early 2026 as I write this and I’m already seeing LinkedIn posts by reputable software engineers and CTOs proclaiming that the cost of software engineering is trending very quickly towards zero.

Most of them cite the era of “Claude Opus 4.5” as the defining moment in the continuum that made them believers. I count myself among this group.

Does this mean that you don’t need to understand software engineering principles anymore?

Well, let’s tackle this question in reverse by asking, “If I don’t know anything about software engineering, can I build meaningful apps just by paying for Claude Code and giving it prompts?”

To answer this question let’s break down the key words:

- “meaningful app” – to me, meaningful would be something innovative, not in terms of cutting-edge technology but definitely a novel application of technology to solve a problem. That’s the bar here
- "[software engineering](/engineers-not-developers/)" – what is this now? This term is also evolving. To me, this is the science and craft of building and maintaining scalable, robust, secure software systems
- "giving it prompts” – this is quickly becoming the new floor for software engineering, and is an art in itself involving not just prompt engineering but context engineering, tool equipping, skills selection and who knows what in 2026

So let's rephrase the question: can I **build and maintain** software that is a **novel** application of technology to solve a problem, that works without **crashing** every other minute, **being vulnerable** to data exfiltration or unwanted manipulation, and for a potentially **large user base**?

The answer in early 2026 in my opinion is actually **yes**. I'm honestly surprised by my own answer.

With just plain English, in 2026, you can:

- Prototype something
- Deploy something to production (i.e. usable by the world)
- Build something that is a novel application of tech to solve a problem
- Read and take seriously the Security Advisories, passing info back into your coding agent to fix them
- Explain scaling bottlenecks and have the AI agent refactor your code base to work better at the new scale

You’re probably expecting me to say something contradictory now. What’s the flip side? What’s the difference between an experienced software engineer using Claude Code versus a geography teacher doing it?

Do I have something to say here?

I’ll think about this and share more in the next article.
